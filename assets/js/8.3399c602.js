(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{219:function(r,e,t){"use strict";t.r(e);var a=t(0),_=Object(a.a)({},(function(){var r=this,e=r.$createElement,t=r._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[t("h1",{attrs:{id:"page-title"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#page-title","aria-hidden":"true"}},[r._v("#")]),r._v(" "+r._s(r.$page.title))]),r._v(" "),t("blockquote",[t("p",[t("a",{attrs:{href:"https://docs.gradle.org/current/userguide/what_is_gradle.html#what_is_gradle",target:"_blank",rel:"noopener noreferrer"}},[r._v("原文链接"),t("OutboundLink")],1)])]),r._v(" "),t("p"),t("div",{staticClass:"table-of-contents"},[t("ul",[t("li",[t("a",{attrs:{href:"#概述"}},[r._v("概述")])]),t("li",[t("a",{attrs:{href:"#您需要了解有关gradle的五件事"}},[r._v("您需要了解有关Gradle的五件事")]),t("ul",[t("li",[t("a",{attrs:{href:"#_1-gradle是通用构建工具"}},[r._v("1.Gradle是通用构建工具")])]),t("li",[t("a",{attrs:{href:"#_2-核心模型基于任务"}},[r._v("2.核心模型基于任务")])]),t("li",[t("a",{attrs:{href:"#_3-gradle有几个固定的构建阶段"}},[r._v("3.Gradle有几个固定的构建阶段")])]),t("li",[t("a",{attrs:{href:"#_4-gradle的扩展方式不止一种"}},[r._v("4.Gradle的扩展方式不止一种")])]),t("li",[t("a",{attrs:{href:"#_5-构建脚本针对api进行操作"}},[r._v("5.构建脚本针对API进行操作")])])])])])]),t("p"),r._v(" "),t("h2",{attrs:{id:"概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概述","aria-hidden":"true"}},[r._v("#")]),r._v(" 概述")]),r._v(" "),t("p",[r._v("Gradle是一个开放源代码的"),t("a",{attrs:{href:"1"}},[r._v("自动化构建")]),r._v("工具，旨在灵活地构建几乎任何类型的软件。以下是其一些最重要功能的高级概述：")]),r._v(" "),t("ul",[t("li",[t("p",[t("strong",[r._v("High performance(高性能)")])]),r._v(" "),t("p",[r._v("Gradle通过仅运行需要运行的任务来避免不必要的工作，因为它们的输入或输出已更改。您还可以使用构建缓存来重用以前运行的任务输出，甚至可以重用其他机器（带有共享构建缓存）的任务输出。")]),r._v(" "),t("p",[r._v("Gradle还实施了许多其他优化措施，并且开发团队不断努力以提高Gradle的性能。")])]),r._v(" "),t("li",[t("p",[t("strong",[r._v("JVM foundation(JVM基础)")])]),r._v(" "),t("p",[r._v("Gradle在JVM上运行，并且必须安装Java开发工具包（JDK）才能使用它。对于熟悉Java平台的用户来说，这是一个好处，因为您可以在构建逻辑中使用标准Java API，例如自定义任务类型和插件。它还使在不同平台上运行Gradle变得容易。")]),r._v(" "),t("p",[r._v("请注意，Gradle不仅限于构建JVM项目，它甚至附带对构建本机项目的支持。")])]),r._v(" "),t("li",[t("p",[t("strong",[r._v("Conventions(约定)")])]),r._v(" "),t("p",[r._v("Gradle从Maven的书中抽出了一片叶子，并使常见类型的项目（例如Java项目）易于通过实现约定来构建。应用适当的插件，您可以轻松地为许多项目使用苗条的构建脚本。但是这些约定并没有限制您：Gradle允许您覆盖它们，添加自己的任务以及对基于约定的构建进行许多其他自定义。")])]),r._v(" "),t("li",[t("p",[t("strong",[r._v("Extensibility(可扩展性)")])]),r._v(" "),t("p",[r._v("您可以轻松扩展Gradle以提供您自己的任务类型甚至构建模型。有关此示例，请参见Android构建支持：它添加了许多新的构建概念，例如口味和构建类型。")])]),r._v(" "),t("li",[t("p",[t("strong",[r._v("IDE support(IDE支持)")])]),r._v(" "),t("p",[r._v("几个主要的IDE允许您导入Gradle构建并与其进行交互：Android Studio，IntelliJ IDEA，Eclipse和NetBeans。 Gradle还支持生成将项目加载到Visual Studio所需的解决方案文件。")])]),r._v(" "),t("li",[t("p",[t("strong",[r._v("Insight(洞察力)")])]),r._v(" "),t("p",[t("a",{attrs:{href:"https://scans.gradle.com/?_ga=2.70265232.1480847771.1569235223-1279986108.1569235223",target:"_blank",rel:"noopener noreferrer"}},[r._v("Build scans"),t("OutboundLink")],1),r._v("提供了有关构建运行的广泛信息，可用于识别构建问题。他们特别擅长帮助您确定构建性能方面的问题。您还可以与其他人共享构建扫描，如果您在解决构建问题时需要征求意见，这将特别有用。")])])]),r._v(" "),t("h2",{attrs:{id:"您需要了解有关gradle的五件事"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#您需要了解有关gradle的五件事","aria-hidden":"true"}},[r._v("#")]),r._v(" 您需要了解有关Gradle的五件事")]),r._v(" "),t("p",[r._v("Gradle是一种灵活而强大的构建工具，当您初次启动时，很容易感到恐惧。但是，了解以下核心原则将使Gradle更加容易上手，并且您将在不了解该工具的情况下熟练掌握它。")]),r._v(" "),t("h3",{attrs:{id:"_1-gradle是通用构建工具"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-gradle是通用构建工具","aria-hidden":"true"}},[r._v("#")]),r._v(" 1.Gradle是通用构建工具")]),r._v(" "),t("p",[r._v("Gradle允许您构建任何软件，因为它对要构建的内容或应如何完成的工作几乎没有任何假设。最明显的限制是，依赖项管理当前仅支持与Maven和Ivy兼容的存储库以及文件系统。")]),r._v(" "),t("p",[r._v("这并不意味着您需要做很多工作来创建构建。借助添加"),t("a",{attrs:{href:"https://docs.gradle.org/current/userguide/plugins.html#plugins",target:"_blank",rel:"noopener noreferrer"}},[r._v("插件"),t("OutboundLink")],1),r._v("的约定和预构建功能，Gradle可以轻松构建常见类型的项目（例如Java库）。您甚至可以创建和发布自定义插件来封装自己的约定并构建功能。")]),r._v(" "),t("h3",{attrs:{id:"_2-核心模型基于任务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-核心模型基于任务","aria-hidden":"true"}},[r._v("#")]),r._v(" 2.核心模型基于任务")]),r._v(" "),t("p",[r._v("Gradle将其构建模型建模为任务（工作单元）的 "),t("strong",[r._v("Directed Acyclic Graphs (DAGs)")]),r._v("。这意味着构建实质上是配置一组任务并将其连接在一起 —— 基于它们的依赖关系 —— 以创建该DAG。创建任务图后，Gradle将确定需要按顺序运行的任务，然后继续执行它们。")]),r._v(" "),t("p",[r._v("此图显示了两个示例任务图，一个是抽象图，另一个是具体图，其中任务之间的依赖性表示为箭头：")]),r._v(" "),t("p",[t("img",{attrs:{src:"https://docs.gradle.org/current/userguide/img/task-dag-examples.png",alt:"Figure 1. Two examples of Gradle task graphs"}})]),r._v(" "),t("p",[r._v("这样，几乎所有构建过程都可以建模为任务图，这就是Gradle如此灵活的原因之一。任务图可以由插件和您自己的构建脚本定义，任务通过任务依赖机制链接在一起。")]),r._v(" "),t("p",[r._v("任务本身包括：")]),r._v(" "),t("ul",[t("li",[t("p",[r._v("Actions: 做某事的工作，例如复制文件或编译源代码")])]),r._v(" "),t("li",[t("p",[r._v("Inputs: actions使用或操作的values，files和directories")])]),r._v(" "),t("li",[t("p",[r._v("Outputs: actions修改或生成的files和directories")])])]),r._v(" "),t("p",[r._v("实际上，以上所有内容都是可选的，具体取决于任务需要执行的操作。有些任务 —— 例如"),t("a",{attrs:{href:"https://docs.gradle.org/current/userguide/base_plugin.html#sec:base_tasks",target:"_blank",rel:"noopener noreferrer"}},[r._v("标准生命周期任务"),t("OutboundLink")],1),r._v(" —— 甚至没有任何动作。他们只是为了方便而将多个任务聚合在一起。")]),r._v(" "),t("div",{staticClass:"tip custom-block"},[t("p",[r._v("您可以选择运行哪个任务。通过指定执行所需任务来节省时间，但不要超过这个范围。如果您只想运行单元测试，请选择执行该任务的任务 —— 通常是"),t("code",[r._v("test")]),r._v("。如果您想打包应用程序，大多数构建都有相应的"),t("code",[r._v("assemble")]),r._v("任务。")])]),r._v(" "),t("p",[r._v("最后一件事：Gradle的"),t("a",{attrs:{href:"https://docs.gradle.org/current/userguide/more_about_tasks.html#sec:up_to_date_checks",target:"_blank",rel:"noopener noreferrer"}},[r._v("增量构建"),t("OutboundLink")],1),r._v("支持是强大且可靠的，因此，除非您确实想要执行清理，否则避免清理任务可保持构建快速运行。")]),r._v(" "),t("h3",{attrs:{id:"_3-gradle有几个固定的构建阶段"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-gradle有几个固定的构建阶段","aria-hidden":"true"}},[r._v("#")]),r._v(" 3.Gradle有几个固定的构建阶段")]),r._v(" "),t("p",[r._v("重要的是要了解Gradle分三个阶段评估和执行构建脚本：")]),r._v(" "),t("ol",[t("li",[t("p",[r._v("Initialization")]),r._v(" "),t("p",[r._v("设置构建环境，并确定哪些项目将参与其中。")])]),r._v(" "),t("li",[t("p",[r._v("Configuration")]),r._v(" "),t("p",[r._v("构造和配置用于构建的任务图，然后根据用户要运行的任务确定需要运行的任务和顺序。")])]),r._v(" "),t("li",[t("p",[r._v("Execution")]),r._v(" "),t("p",[r._v("运行在配置阶段结束时选择的任务。")])])]),r._v(" "),t("p",[r._v("这些阶段构成了Gradle的"),t("a",{attrs:{href:"https://docs.gradle.org/current/userguide/build_lifecycle.html#build_lifecycle",target:"_blank",rel:"noopener noreferrer"}},[r._v("Build Lifecycle"),t("OutboundLink")],1),r._v("。")]),r._v(" "),t("div",{staticClass:"tip custom-block"},[t("p",[t("strong",[r._v("与Apache Maven术语的比较")])]),r._v(" "),t("p",[r._v("Gradle的构建阶段与Maven的阶段不同。 Maven使用其阶段将构建执行划分为多个阶段。它们的作用类似于Gradle的任务图，但灵活性较差。")]),r._v(" "),t("p",[r._v("Maven的构建生命周期概念与Gradle的"),t("a",{attrs:{href:"https://docs.gradle.org/current/userguide/base_plugin.html#sec:base_tasks",target:"_blank",rel:"noopener noreferrer"}},[r._v("lifecycle tasks"),t("OutboundLink")],1),r._v("大致相似。")])]),r._v(" "),t("p",[r._v("设计良好的构建脚本主要由声明性配置而不是命令性逻辑组成。可以理解，在配置阶段评估该配置。即便如此，许多此类构建也具有任务操作（例如，通过"),t("code",[r._v("doLast {}")]),r._v(" 和"),t("code",[r._v("doFirst {}")]),r._v("块），这些任务在执行阶段进行评估。这很重要，因为在配置阶段评估的代码不会看到在执行阶段发生的更改。")]),r._v(" "),t("p",[r._v("配置阶段的另一个重要方面是，每次运行构建时都会评估其中涉及的所有内容。因此，最佳做法是"),t("a",{attrs:{href:"https://docs.gradle.org/current/userguide/authoring_maintainable_build_scripts.html#sec:minimize_logic_executed_configuration_phase",target:"_blank",rel:"noopener noreferrer"}},[r._v("在配置阶段避免昂贵的工作"),t("OutboundLink")],1),r._v("。"),t("a",{attrs:{href:"https://scans.gradle.com/?_ga=2.65399086.1480847771.1569235223-1279986108.1569235223",target:"_blank",rel:"noopener noreferrer"}},[r._v("Build scans"),t("OutboundLink")],1),r._v("可以帮助您识别此类热点。")]),r._v(" "),t("h3",{attrs:{id:"_4-gradle的扩展方式不止一种"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-gradle的扩展方式不止一种","aria-hidden":"true"}},[r._v("#")]),r._v(" 4.Gradle的扩展方式不止一种")]),r._v(" "),t("p",[r._v("如果您可以仅使用Gradle捆绑的构建逻辑来构建项目，那将是很好的，但是这种情况很少发生。大多数构建都有一些特殊要求，这意味着您需要添加自定义构建逻辑。")]),r._v(" "),t("p",[r._v("Gradle提供了多种机制来扩展它，例如：")]),r._v(" "),t("ul",[t("li",[t("p",[t("a",{attrs:{href:"#custom_task"}},[r._v("自定义任务类型")]),r._v("。")]),r._v(" "),t("p",[r._v("当您希望构建完成现有任务无法完成的工作时，只需编写自己的任务类型即可。通常最好将自定义任务类型的源文件放在"),t("a",{attrs:{href:"https://docs.gradle.org/current/userguide/organizing_gradle_projects.html#sec:build_sources",target:"_blank",rel:"noopener noreferrer"}},[r._v("buildSrc"),t("OutboundLink")],1),r._v("目录或打包的插件中。然后，您可以像Gradle提供的任何任务一样使用自定义任务类型。")])]),r._v(" "),t("li",[t("p",[r._v("自定义任务操作。")]),r._v(" "),t("p",[r._v("您可以通过"),t("code",[r._v("Task.doFirst()")]),r._v("和"),t("code",[r._v("Task.doLast()")]),r._v("方法附加在任务之前或之后执行的自定义构建逻辑。")])]),r._v(" "),t("li",[t("p",[t("a",{attrs:{href:"https://docs.gradle.org/current/userguide/writing_build_scripts.html#sec:extra_properties",target:"_blank",rel:"noopener noreferrer"}},[r._v("projects"),t("OutboundLink")],1),r._v("和"),t("a",{attrs:{href:"https://docs.gradle.org/current/userguide/writing_build_scripts.html#sec:extra_task_properties",target:"_blank",rel:"noopener noreferrer"}},[r._v("tasks"),t("OutboundLink")],1),r._v("的额外属性。")]),r._v(" "),t("p",[r._v("这些允许您将自己的属性添加到项目或任务中，然后可以从您自己的自定义操作或任何其他构建逻辑中使用它们。甚至可以将额外的属性应用于您未明确创建的任务，例如由Gradle的核心插件创建的任务。")])]),r._v(" "),t("li",[t("p",[r._v("自定义约定。")]),r._v(" "),t("p",[r._v("约定是简化构建的强大方法，因此用户可以更轻松地理解和使用它们。使用标准项目结构和命名约定的构建（例如"),t("a",{attrs:{href:"https://docs.gradle.org/current/userguide/building_java_projects.html#building_java_projects",target:"_blank",rel:"noopener noreferrer"}},[r._v("Java builds"),t("OutboundLink")],1),r._v("）可以看到这一点。您可以编写自己的提供约定的插件 —— 它们只需要为构建的相关方面配置默认值。")])]),r._v(" "),t("li",[t("p",[t("a",{attrs:{href:"https://guides.gradle.org/implementing-gradle-plugins/#modeling_dsl_like_apis",target:"_blank",rel:"noopener noreferrer"}},[r._v("自定义模型"),t("OutboundLink")],1),r._v("。")]),r._v(" "),t("p",[r._v("Gradle允许您将新概念引入除任务，文件和依赖项配置之外的内部版本。您可以在大多数语言插件中看到这一点，这些插件将"),t("a",{attrs:{href:"https://docs.gradle.org/current/userguide/building_java_projects.html#sec:java_source_sets",target:"_blank",rel:"noopener noreferrer"}},[r._v("source sets"),t("OutboundLink")],1),r._v("的概念添加到了构建中。对构建过程进行适当的建模可以大大提高构建的易用性及其效率。")])])]),r._v(" "),t("h3",{attrs:{id:"_5-构建脚本针对api进行操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-构建脚本针对api进行操作","aria-hidden":"true"}},[r._v("#")]),r._v(" 5.构建脚本针对API进行操作")]),r._v(" "),t("p",[r._v("将Gradle的构建脚本视为可执行代码很容易，因为这就是它们。但这只是一个实现细节：精心设计的构建脚本描述了构建软件所需的步骤，而不是这些步骤应如何工作。这是定制任务类型和插件的工作。")]),r._v(" "),t("div",{staticClass:"tip custom-block"},[t("p",[r._v("人们普遍误认为Gradle的功能和灵活性来自其构建脚本是代码这一事实。这与事实相去甚远。正是底层模型和API提供了强大的功能。正如我们在最佳实践中建议的那样，您应该"),t("a",{attrs:{href:"https://docs.gradle.org/current/userguide/authoring_maintainable_build_scripts.html#sec:avoid_imperative_logic_in_scripts",target:"_blank",rel:"noopener noreferrer"}},[r._v("避免在构建脚本中放置太多（如果有）命令式逻辑"),t("OutboundLink")],1),r._v("。")])]),r._v(" "),t("p",[r._v("然而，在一个区域中，将构建脚本视为可执行代码很有用：了解构建脚本的语法如何映射到Gradle的API。由"),t("a",{attrs:{href:"https://docs.gradle.org/current/dsl/",target:"_blank",rel:"noopener noreferrer"}},[r._v("Groovy DSL Reference"),t("OutboundLink")],1),r._v("和"),t("a",{attrs:{href:"https://docs.gradle.org/current/javadoc/",target:"_blank",rel:"noopener noreferrer"}},[r._v("Javadocs"),t("OutboundLink")],1),r._v("组成的API文档列出了方法和属性，并引用了闭包和操作。这些在构建脚本的上下文中是什么意思？查看"),t("a",{attrs:{href:"https://docs.gradle.org/current/userguide/groovy_build_script_primer.html#groovy_build_script_primer",target:"_blank",rel:"noopener noreferrer"}},[r._v("Groovy Build Script Primer"),t("OutboundLink")],1),r._v("，以了解该问题的答案，以便您可以有效地使用API​​文档。")]),r._v(" "),t("div",{staticClass:"tip custom-block"},[t("p",[r._v("由于Gradle在JVM上运行，因此构建脚本也可以使用标准"),t("a",{attrs:{href:"https://docs.oracle.com/javase/8/docs/api/",target:"_blank",rel:"noopener noreferrer"}},[r._v("Java API"),t("OutboundLink")],1),r._v("。 Groovy构建脚本可以另外使用Groovy API，而Kotlin构建脚本可以使用Kotlin。")])])])}),[],!1,null,null,null);e.default=_.exports}}]);